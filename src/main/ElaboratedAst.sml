(**
 * data structures generated by elaboration.
 *
 * @author YAMATODANI Kiyoshi
 * @version $Id: ElaboratedAst.sml,v 1.7 2006/10/12 22:00:04 kiyoshiy Exp $
 *)
structure ElaboratedAst =
struct

  (***************************************************************************)

  type loc = AnnotatedAst.loc

  type path = string list

  datatype moduleType =
           STRUCTURE
         | SIGNATURE
         | FUNCTOR
         | FUNCTORSIGNATURE
         | FUNCTORPARAMETER_STRUCTURE
         | ANONYMOUS_FUNCTORPARAMETER_STRUCTURE

  type moduleFQN = (moduleType * string) list

  datatype moduleReference =
           UnknownRef of path
         | ModuleRef of
           ((** absolute FQN of the dest module used to link. *)
            moduleFQN *
            (** relative path used as display string . *)
            path)
         | ExternalRef of moduleFQN * string
  type typeReference = moduleReference * path
  type exceptionReference = moduleReference * path

  datatype 'a sigConst =
           NoSig
         | Transparent of 'a
         | Opaque of 'a

  type tyvar = string

  (** STRUCTURE EXPRESSION *)
  datatype strexp =
           (** variable structure *)
           VarStr of moduleReference
         | (** basic structure (struct...end) *)
           BaseStr of decSet 
         | (** constrained sig *)
           ConstrainedStr of strexp * sigexp sigConst 
	 | (** application (external) *)
           AppStr of moduleReference * (strexp * bool) list 

  (** FUNCTOR EXPRESSION *)
  and fctexp =
      (** functor variable *)
      VarFct of moduleReference * fsigexp sigConst
    | (** definition of a functor *)
      BaseFct of
      {	
        params : (string option * sigexp) list,
        body : strexp,
        constraint : sigexp sigConst
      }
    | (** application *)
      AppFct of moduleReference * (strexp * bool) list * fsigexp sigConst

  (** WHERE SPEC *)
  and wherespec =
      WhType of string list * tyvar list * ty
    | WhStruct of string list * moduleReference

  (** SIGNATURE EXPRESSION *)
  and sigexp =
      (** signature variable *)
      VarSig of moduleReference
    | (** sig augmented with where specs *)
      AugSig of sigexp * wherespec list list
    | (** basic signature (sig...end) *)
      BaseSig of specSet

  (** FUNCTOR SIGNATURE EXPRESSION *)
  and fsigexp =
      (** funsig variable *)
      VarFsig of moduleReference
    | (** basic funsig *)
      BaseFsig of {params : (string option * sigexp) list, result : sigexp}

  (** SPECIFICATION FOR SIGNATURE DEFINITIONS *)
  and specSet =
      SpecSet of
      {
        (** structure *)
        strs : sigb list,
        (** functor *)
        fcts : fsigb list,
        (** structure sharing *)
        shareStrs : moduleReference list list,
        (** type sharing *)
        shareTycs : typeReference list list,
        (** include specif *)
        includes : sigexp list,
        (** types *)
        types : tb list,
        (** datatype *)
        datatypes : db list,
        (** exception *)
        exceptions : eb list,
        (** value *)
        vals : vb list
      }

  (** DECLARATIONS (let and structure) *)
  and decSet =
      DecSet of
      {
        (** structure *)
        strs : strb list,
        (** functor *)
        fcts : fctb list,
        (** signature *)
        sigs : sigb list,
        (** funsig *)
        fsigs : fsigb list,
        (** opens *)
        opens : moduleReference list,
        (** type dec *)
        types : tb list,
        (** datatype dec *)
        datatypes : db list,
        (** exception *)
        exceptions : eb list, 
        (** values *)
        vals : vb list
      }

  and strb =
      STRB of
      (moduleFQN * string * loc * strexp * sigexp sigConst * optDocComment)

  and fctb =
      FCTB of (moduleFQN * string * loc * fctexp * optDocComment)

  and sigb =
      SIGB of (moduleFQN * string * loc * sigexp * path option * optDocComment)

  and fsigb =
      FSIGB of (moduleFQN * string * loc * fsigexp * optDocComment)

  and tb =
      TB of
      (
        moduleFQN *
        string *
        loc *
        tyvar list *
        ty option *
        (** isEqtype *) bool *
        optDocComment
      )

  and db =
      DB of (moduleFQN * string * loc * tyvar list * dbrhs * optDocComment)

  and vb =
      VB of (moduleFQN * string * loc * ty option * optDocComment)

  (** DATATYPE BINDING RIGHT HAND SIDE *)
  and dbrhs =
      Constrs of cb list
    | Repl of typeReference

  and cb =
      CB of (moduleFQN * string * loc * ty option * ty * optDocComment)

  (** EXCEPTION BINDING *)
  and eb =
      EBGen of (moduleFQN * string * loc * ty option * optDocComment)
    | EBDef of (moduleFQN * string * loc * exceptionReference * optDocComment)

  (** TYPES *)
  and ty =
      (** type variable *)
      VarTy of tyvar 
    | (** type constructor *)
      ConTy of typeReference * ty list
    | (** function type *)
      FunTy of ty * ty
    | (** record *)
      RecordTy of (string * ty * optDocComment) list 
    | (** tuple *)
      TupleTy of ty list
    | (** with comment *)
      CommentedTy of docComment * ty

  and paramPattern =
      IDParamPat of (string * ty option)
    | TupleParamPat of paramPattern list
    | RecordParamPat of (string * paramPattern) list

  and tagSet =
      TagSet of
      {
        authors : string list,
        contributors : string list,
        copyrights : string list,
        exceptions : (exceptionReference * string) list,
        params : (string * ty option * string) list,
        paramPattern : (paramPattern list) option,
        return : string option,
        sees : string list,
        version : string option
      }

  withtype docComment = string * string * tagSet 

  and optDocComment = (string * string * tagSet) option

  datatype compileUnit =
           CompileUnit of string * decSet

  (***************************************************************************)

  fun pathToString path = Utility.interleaveString "." path

  fun moduleFQNToPath moduleFQN =
      let
        val FQN =
            List.filter
            (fn (ANONYMOUS_FUNCTORPARAMETER_STRUCTURE, _) => false | _ => true)
            moduleFQN
      in
        map (fn (_, name) => name) FQN
      end

  fun moduleFQNToString moduleFQN = pathToString(moduleFQNToPath moduleFQN)

  fun isFQNOfFunctorParameter FQN =
      List.exists
          (fn (FUNCTORPARAMETER_STRUCTURE, _) => true
            | (ANONYMOUS_FUNCTORPARAMETER_STRUCTURE, _) => true
            | _ => false)
          FQN

  (****************************************)

  val emptySpecSet = 
      SpecSet
      {
        strs = [], types = [], fcts = [], vals = [], datatypes = [],
        exceptions = [], shareStrs = [], shareTycs = [], includes = []
      }

  fun appendSpecSet (SpecSet left, SpecSet right) =
      SpecSet
      {
        strs = (#strs left) @ (#strs right),
        types = (#types left) @ (#types right),
        fcts = (#fcts left) @ (#fcts right),
        vals = (#vals left) @ (#vals right),
        datatypes = (#datatypes left) @ (#datatypes right),
        exceptions = (#exceptions left) @ (#exceptions right),
        shareStrs = (#shareStrs left) @ (#shareStrs right),
        shareTycs = (#shareTycs left) @ (#shareTycs right),
        includes = (#includes left) @ (#includes right)
      }

  val emptyDecSet =
      DecSet
      {
        vals = [], types = [], datatypes = [], exceptions = [],
        strs = [], fcts = [], sigs = [], fsigs = [], opens = []
      }

  fun appendDecSet (DecSet left, DecSet right) =
      DecSet
      {
        vals = (#vals left) @ (#vals right),
        types = (#types left) @ (#types right),
        datatypes = (#datatypes left) @ (#datatypes right),
        exceptions = (#exceptions left) @ (#exceptions right),
        strs = (#strs left) @ (#strs right),
        fcts = (#fcts left) @ (#fcts right),
        sigs = (#sigs left) @ (#sigs right),
        fsigs = (#fsigs left) @ (#fsigs right),
        opens = (#opens left) @ (#opens right)
      }

  (***************************************************************************)

end

